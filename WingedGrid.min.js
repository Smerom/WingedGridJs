function baseIcosahedron(){var e=new WingedGrid(0,0,0)
e.faces=[{edges:[9,4,0]},{edges:[1,5,0]},{edges:[2,6,1]},{edges:[3,7,2]},{edges:[4,8,3]},{edges:[14,19,10]},{edges:[15,11,10]},{edges:[16,12,11]},{edges:[17,13,12]},{edges:[18,14,13]},{edges:[29,28,9]},{edges:[29,20,17]},{edges:[21,20,5]},{edges:[21,22,18]},{edges:[23,22,6]},{edges:[23,24,19]},{edges:[25,24,7]},{edges:[25,26,15]},{edges:[27,26,8]},{edges:[27,28,16]}]
var r=1.61803398875
return e.vertices=[{coords:[0,1,r],edges:[4,3,2,1,0],vertexNeighbors:[]},{coords:[0,1,-r],edges:[19,24,25,15,10],vertexNeighbors:[]},{coords:[0,-1,r],edges:[5,20,29,9,0],vertexNeighbors:[]},{coords:[0,-1,-r],edges:[11,12,13,14,10],vertexNeighbors:[]},{coords:[-r,0,1],edges:[6,22,21,5,1],vertexNeighbors:[]},{coords:[r,0,1],edges:[9,28,27,8,4],vertexNeighbors:[]},{coords:[-r,0,-1],edges:[18,22,23,19,14],vertexNeighbors:[]},{coords:[r,0,-1],edges:[15,26,27,16,11],vertexNeighbors:[]},{coords:[-1,r,0],edges:[7,24,23,6,2],vertexNeighbors:[]},{coords:[-1,-r,0],edges:[17,20,21,18,13],vertexNeighbors:[]},{coords:[1,r,0],edges:[8,26,25,7,3],vertexNeighbors:[]},{coords:[1,-r,0],edges:[16,28,29,17,12],vertexNeighbors:[]}],e.edges=[{firstVertexA:0,firstVertexB:2,faceA:0,faceB:1,prevA:4,nextA:9,prevB:5,nextB:1},{firstVertexA:0,firstVertexB:4,faceA:1,faceB:2,prevA:0,nextA:5,prevB:6,nextB:2},{firstVertexA:0,firstVertexB:8,faceA:2,faceB:3,prevA:1,nextA:6,prevB:7,nextB:3},{firstVertexA:0,firstVertexB:10,faceA:3,faceB:4,prevA:2,nextA:7,prevB:8,nextB:4},{firstVertexA:0,firstVertexB:5,faceA:4,faceB:0,prevA:3,nextA:8,prevB:9,nextB:0},{firstVertexA:4,firstVertexB:2,faceA:1,faceB:12,prevA:1,nextA:0,prevB:20,nextB:21},{firstVertexA:8,firstVertexB:4,faceA:2,faceB:14,prevA:2,nextA:1,prevB:22,nextB:23},{firstVertexA:10,firstVertexB:8,faceA:3,faceB:16,prevA:3,nextA:2,prevB:24,nextB:25},{firstVertexA:5,firstVertexB:10,faceA:4,faceB:18,prevA:4,nextA:3,prevB:26,nextB:27},{firstVertexA:2,firstVertexB:5,faceA:0,faceB:10,prevA:0,nextA:4,prevB:28,nextB:29},{firstVertexA:1,firstVertexB:3,faceA:5,faceB:6,prevA:19,nextA:14,prevB:11,nextB:15},{firstVertexA:7,firstVertexB:3,faceA:6,faceB:7,prevA:15,nextA:10,prevB:12,nextB:16},{firstVertexA:11,firstVertexB:3,faceA:7,faceB:8,prevA:16,nextA:11,prevB:13,nextB:17},{firstVertexA:9,firstVertexB:3,faceA:8,faceB:9,prevA:17,nextA:12,prevB:14,nextB:18},{firstVertexA:6,firstVertexB:3,faceA:9,faceB:5,prevA:18,nextA:13,prevB:10,nextB:19},{firstVertexA:1,firstVertexB:7,faceA:6,faceB:17,prevA:10,nextA:11,prevB:26,nextB:25},{firstVertexA:7,firstVertexB:11,faceA:7,faceB:19,prevA:11,nextA:12,prevB:28,nextB:27},{firstVertexA:11,firstVertexB:9,faceA:8,faceB:11,prevA:12,nextA:13,prevB:20,nextB:29},{firstVertexA:9,firstVertexB:6,faceA:9,faceB:13,prevA:13,nextA:14,prevB:22,nextB:21},{firstVertexA:6,firstVertexB:1,faceA:5,faceB:15,prevA:14,nextA:10,prevB:24,nextB:23},{firstVertexA:2,firstVertexB:9,faceA:11,faceB:12,prevA:29,nextA:17,prevB:21,nextB:5},{firstVertexA:4,firstVertexB:9,faceA:12,faceB:13,prevA:5,nextA:20,prevB:18,nextB:22},{firstVertexA:4,firstVertexB:6,faceA:13,faceB:14,prevA:21,nextA:18,prevB:23,nextB:6},{firstVertexA:8,firstVertexB:6,faceA:14,faceB:15,prevA:6,nextA:22,prevB:19,nextB:24},{firstVertexA:8,firstVertexB:1,faceA:15,faceB:16,prevA:23,nextA:19,prevB:25,nextB:7},{firstVertexA:10,firstVertexB:1,faceA:16,faceB:17,prevA:7,nextA:24,prevB:15,nextB:26},{firstVertexA:10,firstVertexB:7,faceA:17,faceB:18,prevA:25,nextA:15,prevB:27,nextB:8},{firstVertexA:5,firstVertexB:7,faceA:18,faceB:19,prevA:8,nextA:26,prevB:16,nextB:28},{firstVertexA:5,firstVertexB:11,faceA:19,faceB:10,prevA:27,nextA:16,prevB:29,nextB:9},{firstVertexA:2,firstVertexB:11,faceA:10,faceB:11,prevA:9,nextA:28,prevB:17,nextB:20}],[e,null]}function vectorAngle(e,r){return Math.acos((e[0]*r[0]+e[1]*r[1]+e[2]*r[2])/(Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])*Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2])))}function vectorLength(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}var WingedEdge=function(){function e(){}return e.prototype.nextEdgeForFace=function(e){return this.faceA==e?[this.nextA,null]:this.faceB==e?[this.nextB,null]:[-1,Error("Edge not associated with face.")]},e.prototype.prevEdgeForFace=function(e){return this.faceA==e?[this.prevA,null]:this.faceB==e?[this.prevB,null]:[-1,Error("Edge not associated with face.")]},e.prototype.firstVertexForFace=function(e){return this.faceA==e?[this.firstVertexA,null]:this.faceB==e?[this.firstVertexB,null]:[-1,Error("Edge not associated with face.")]},e.prototype.secondVertexForFace=function(e){return this.faceA==e?[this.firstVertexB,null]:this.faceB==e?[this.firstVertexA,null]:[-1,Error("Edge not associated with face.")]},e.prototype.nextEdgeForVertex=function(e){return this.firstVertexA==e?this.prevEdgeForFace(this.faceA):this.firstVertexB==e?this.prevEdgeForFace(this.faceB):[-1,Error("Edge not associated with vertex.")]},e.prototype.prevEdgeForVertex=function(e){return this.firstVertexA==e?this.nextEdgeForFace(this.faceB):this.firstVertexB==e?this.nextEdgeForFace(this.faceA):[-1,Error("Edge not associated with vertex.")]},e.prototype.adjacentForFace=function(e){return this.faceA==e?[this.faceB,null]:this.faceB==e?[this.faceA,null]:[-1,Error("Edge not associated with face.")]},e.prototype.adjacentForVertex=function(e){return this.firstVertexA==e?[this.firstVertexB,null]:this.firstVertexB==e?[this.firstVertexA,null]:[-1,Error("Edge not associated with vertex.")]},e}(),WingedFace=function(){function e(){this.edges=new Array}return e}(),WingedVertex=function(){function e(){this.coords=[0,0,0],this.edges=new Array,this.vertexNeighbors=new Array}return e}(),WingedGrid=function(){function e(e,r,t){this.faces=new Array(e)
for(var s=this.faces.length-1;s>=0;s--)this.faces[s]=new WingedFace
this.edges=new Array(r)
for(var s=this.edges.length-1;s>=0;s--)this.edges[s]=new WingedEdge
this.vertices=new Array(t)
for(var s=this.vertices.length-1;s>=0;s--)this.vertices[s]=new WingedVertex}return e.prototype.neighborsForFace=function(e){for(var r=Array(),t=this.faces[e].edges.length-1;t>=0;t--){var s=this.edges[this.faces[e].edges[t]].adjacentForFace(e),i=s[0]
s[1]
r[t]=i}return r},e.prototype.neighborsForVertex=function(e){var r=Array()
if(0==this.vertices[e].vertexNeighbors.length)for(var t=this.vertices[e].edges.length-1;t>=0;t--){var s=this.edges[this.vertices[e].edges[t]].adjacentForVertex(e),i=s[0]
s[1]
this.vertices[e].vertexNeighbors[t]=i}return r},e.prototype.normalizeVerticesToDistanceFromOrigin=function(e){for(var r=this.vertices.length-1;r>=0;r--){var t=this.vertices[r],s=vectorLength(t.coords)
this.vertices[r].coords[0]=t.coords[0]*e/s,this.vertices[r].coords[1]=t.coords[1]*e/s,this.vertices[r].coords[2]=t.coords[2]*e/s}},e.prototype.createDual=function(){for(var r=new e(this.vertices.length,this.edges.length,this.faces.length),t=this.vertices.length-1;t>=0;t--)for(var s=this.vertices[t],i=s.edges.length-1;i>=0;i--)r.faces[t].edges[i]=s.edges[i]
for(var t=this.faces.length-1;t>=0;t--){for(var d=this.faces[t],i=d.edges.length-1;i>=0;i--)r.vertices[t].edges[i]=d.edges[i]
for(var o=[0,0,0],c=0,i=d.edges.length-1;i>=0;i--){var f=this.edges[d.edges[i]],n=f.firstVertexForFace(t),x=n[0],g=n[1]
if(null!=g)return[r,g]
var s=this.vertices[x]
o[0]+=s.coords[0],o[1]+=s.coords[1],o[2]+=s.coords[2],c+=1}r.vertices[t].coords[0]=o[0]/c,r.vertices[t].coords[1]=o[1]/c,r.vertices[t].coords[2]=o[2]/c}for(var t=this.edges.length-1;t>=0;t--){var f=this.edges[t]
r.edges[t].faceA=f.firstVertexA,r.edges[t].faceB=f.firstVertexB,r.edges[t].firstVertexA=f.faceB,r.edges[t].firstVertexB=f.faceA}for(var a=r.faces.length-1;a>=0;a--)for(var d=r.faces[a],v=d.edges.length-1;v>=0;v--){var A=d.edges[v],h=r.edges[A]
h.faceA==a&&(0==v?(r.edges[A].prevA=d.edges[d.edges.length-1],r.edges[A].nextA=d.edges[1]):v==d.edges.length-1?(r.edges[A].prevA=d.edges[d.edges.length-1],r.edges[A].nextA=d.edges[0]):(r.edges[A].prevA=d.edges[v-1],r.edges[A].nextA=d.edges[v+1])),h.faceB==a&&(0==v?(r.edges[A].prevB=d.edges[d.edges.length-1],r.edges[A].nextB=d.edges[1]):v==d.edges.length-1?(r.edges[A].prevB=d.edges[d.edges.length-1],r.edges[A].nextB=d.edges[0]):(r.edges[A].prevB=d.edges[v-1],r.edges[A].nextB=d.edges[v+1]))}return[r,null]},e.prototype.vertexIndexAtClockwiseIndexOnOldFace=function(e,r,t,s){var i=this.faces[e].edges[r],d=this.edges[i]
return d.faceA==e?this.vertices.length+i*s+t:d.faceB==e?this.vertices.length+i*s+s-1-t:-1},e.prototype.edgeIndexAtClockwiseIndexOnOldFace=function(e,r,t,s){var i=this.faces[e].edges[r],d=this.edges[i]
return d.faceA==e?i*(s+1)+t:d.faceB==e?i*(s+1)+s-t:-1},e.prototype.subdivideTriangles=function(r){if(r<1)return[null,Error("Invalid number of subdivisions.")]
for(var t=this.faces.length*((r+2)*(r+1)/2+(r+1)*r/2),s=new e(t,3*t/2,t/2+2),i=0;i<t;i++)s.faces[i].edges=[-1,-1,-1]
for(var d=0;d<3*t/2;d++)s.edges[d].faceA=-1,s.edges[d].faceB=-1,s.edges[d].firstVertexA=-1,s.edges[d].firstVertexB=-1,s.edges[d].nextA=-1,s.edges[d].nextB=-1,s.edges[d].prevA=-1,s.edges[d].prevB=-1
for(var o=0;o<this.vertices.length;o++){s.vertices[o].edges=new Array(this.vertices[o].edges.length)
for(var c=0;c<this.vertices[o].edges.length;c++)s.vertices[o].edges[c]=-1
s.vertices[o].coords=[1/0,1/0,1/0]}for(var f=this.vertices.length;f<t/2+2;f++)s.vertices[f].edges=[-1,-1,-1,-1,-1,-1],s.vertices[f].coords=[1/0,1/0,1/0]
for(var n=this.vertices.length,x=this.edges.length,g=this.edges.length-1;g>=0;g--){var a=this.edges[g]
s.edges[g*(r+1)].firstVertexA=a.firstVertexA,s.edges[g*(r+1)].firstVertexB=n+g*r
for(var c=1;c<r;c++)s.edges[g*(r+1)+c].firstVertexA=n+g*r+c-1,s.edges[g*(r+1)+c].firstVertexB=n+g*r+c
s.edges[g*(r+1)+r].firstVertexA=n+g*r+r-1,s.edges[g*(r+1)+r].firstVertexB=a.firstVertexB}for(var v=this.faces.length-1;v>=0;v--){var A=this.faces[v],h=n+x*r+r*(r-1)/2*v,B=(r+1)*x+3*r*(r+1)/2*v
if(1==r)s.edges[B+0].firstVertexA=n+A.edges[0],s.edges[B+0].firstVertexB=n+A.edges[1],s.edges[B+1].firstVertexA=n+A.edges[0],s.edges[B+1].firstVertexB=n+A.edges[2],s.edges[B+2].firstVertexA=n+A.edges[1],s.edges[B+2].firstVertexB=n+A.edges[2]
else{s.edges[B+0].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,r-1,r),s.edges[B+0].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,0,r),s.edges[B+1].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,r-1,r),s.edges[B+1].firstVertexB=h+0,s.edges[B+2].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,0,r),s.edges[B+2].firstVertexB=h+0
var V,l=0
for(l=1;l<r-1;l++){V=l*(l+1)*3/2,s.edges[B+V+0].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,r-1-l,r),s.edges[B+V+0].firstVertexB=h+l*(l-1)/2,s.edges[B+V+1].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,r-1-l,r),s.edges[B+V+1].firstVertexB=h+l*(l-1)/2+l,s.edges[B+V+2].firstVertexA=h+l*(l-1)/2,s.edges[B+V+2].firstVertexB=h+l*(l-1)/2+l
for(var c=1;c<l;c++)s.edges[B+V+3*c+0].firstVertexA=h+l*(l-1)/2+c-1,s.edges[B+V+3*c+0].firstVertexB=h+l*(l-1)/2+c,s.edges[B+V+3*c+1].firstVertexA=h+l*(l-1)/2+c-1,s.edges[B+V+3*c+1].firstVertexB=h+l*(l-1)/2+l+c,s.edges[B+V+3*c+2].firstVertexA=h+l*(l-1)/2+c,s.edges[B+V+3*c+2].firstVertexB=h+l*(l-1)/2+l+c
s.edges[B+V+3*l+0].firstVertexA=h+l*(l-1)/2+l-1,s.edges[B+V+3*l+0].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,l,r),s.edges[B+V+3*l+1].firstVertexA=h+l*(l-1)/2+l-1,s.edges[B+V+3*l+1].firstVertexB=h+l*(l-1)/2+2*l,s.edges[B+V+3*l+2].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,l,r),s.edges[B+V+3*l+2].firstVertexB=h+l*(l-1)/2+2*l}l=r-1,V=l*(l+1)*3/2,s.edges[B+V+0].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,0,r),s.edges[B+V+0].firstVertexB=h+l*(l-1)/2,s.edges[B+V+1].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,0,0,r),s.edges[B+V+1].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,r-1,r),s.edges[B+V+2].firstVertexA=h+l*(l-1)/2,s.edges[B+V+2].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,r-1,r)
for(var c=1;c<l;c++)s.edges[B+V+3*c+0].firstVertexA=h+l*(l-1)/2+c-1,s.edges[B+V+3*c+0].firstVertexB=h+l*(l-1)/2+c,s.edges[B+V+3*c+1].firstVertexA=h+l*(l-1)/2+c-1,s.edges[B+V+3*c+1].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,r-c-1,r),s.edges[B+V+3*c+2].firstVertexA=h+l*(l-1)/2+c,s.edges[B+V+3*c+2].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,r-c-1,r)
s.edges[B+V+3*l+0].firstVertexA=h+l*(l-1)/2+l-1,s.edges[B+V+3*l+0].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,l,r),s.edges[B+V+3*l+1].firstVertexA=h+l*(l-1)/2+l-1,s.edges[B+V+3*l+1].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,0,r),s.edges[B+V+3*l+2].firstVertexA=this.vertexIndexAtClockwiseIndexOnOldFace(v,1,l,r),s.edges[B+V+3*l+2].firstVertexB=this.vertexIndexAtClockwiseIndexOnOldFace(v,2,0,r)}}for(var p=this.faces.length-1;p>=0;p--){var F=(r+2)*(r+1)/2+(r+1)*r/2,u=3*r*(r+1)/2,I=F*p,B=(r+1)*x+u*p
s.faces[I+0].edges=[this.edgeIndexAtClockwiseIndexOnOldFace(p,0,r,r),this.edgeIndexAtClockwiseIndexOnOldFace(p,1,0,r),B]
for(var O=1;O<r;O++){var w=O*(O+1)/2+O*(O-1)/2
s.faces[I+w+0].edges=[this.edgeIndexAtClockwiseIndexOnOldFace(p,0,r-O,r),B+O*(O-1)*3/2+1,B+O*(O+1)*3/2]
for(var c=1;c<(O+1)*(O+2)/2+(O+1)*O/2-w-1;c++)c%2==1?s.faces[I+w+c].edges=[B+O*(O-1)*3/2+3*(c-1)/2,B+O*(O-1)*3/2+3*(c-1)/2+2,B+O*(O-1)*3/2+3*(c-1)/2+1]:s.faces[I+w+c].edges=[B+O*(O+1)*3/2+3*c/2,B+O*(O-1)*3/2+3*(c-2)/2+2,B+O*(O-1)*3/2+3*c/2+1]
s.faces[I+(O+1)*(O+2)/2+(O+1)*O/2-1].edges=[B+O*(O+1)*3/2+3*((O+1)*(O+2)/2+(O+1)*O/2-w-1)/2,B+O*(O-1)*3/2+3*((O+1)*(O+2)/2+(O+1)*O/2-w-3)/2+2,this.edgeIndexAtClockwiseIndexOnOldFace(p,1,O,r)]}var w=r*(r+1)/2+r*(r-1)/2
s.faces[I+w+0].edges=[this.edgeIndexAtClockwiseIndexOnOldFace(p,0,0,r),B+r*(r-1)*3/2+1,this.edgeIndexAtClockwiseIndexOnOldFace(p,2,r,r)]
for(var c=1;c<F-w-1;c++)c%2==1?s.faces[I+w+c].edges=[B+r*(r-1)*3/2+3*(c-1)/2,B+r*(r-1)*3/2+3*(c-1)/2+2,B+r*(r-1)*3/2+3*(c-1)/2+1]:s.faces[I+w+c].edges=[this.edgeIndexAtClockwiseIndexOnOldFace(p,2,r-c/2,r),B+r*(r-1)*3/2+3*(c-2)/2+2,B+r*(r-1)*3/2+3*c/2+1]
s.faces[I+F-1].edges=[this.edgeIndexAtClockwiseIndexOnOldFace(p,2,0,r),B+r*(r-1)*3/2+3*(F-w-3)/2+2,this.edgeIndexAtClockwiseIndexOnOldFace(p,1,r,r)]}for(var b=s.faces.length-1;b>=0;b--){var E,k=s.faces[b].edges,C=k.length,y=s.edges[k[C-1]],N=s.edges[k[0]],W=s.edges[k[1]]
N.firstVertexA==y.firstVertexA||N.firstVertexA==y.firstVertexB?N.firstVertexB==W.firstVertexA||N.firstVertexB==W.firstVertexB?N.faceA==-1?(s.edges[k[0]].faceA=b,s.edges[k[0]].prevA=k[C-1],s.edges[k[0]].nextA=k[1]):console.log("For face "+b+". Face A has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):N.firstVertexB==y.firstVertexA||N.firstVertexB==y.firstVertexB?N.firstVertexA==W.firstVertexA||N.firstVertexA==W.firstVertexB?N.faceB==-1?(s.edges[k[0]].faceB=b,s.edges[k[0]].prevB=k[C-1],s.edges[k[0]].nextB=k[1]):console.log("For face "+b+". Face B has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):console.log("For face "+b+". Edges Don't share a vertex!")
for(var L=1;L<C-1;L++)y=s.edges[k[L-1]],N=s.edges[k[L]],W=s.edges[k[L+1]],N.firstVertexA==y.firstVertexA||N.firstVertexA==y.firstVertexB?N.firstVertexB==W.firstVertexA||N.firstVertexB==W.firstVertexB?N.faceA==-1?(s.edges[k[L]].faceA=b,s.edges[k[L]].prevA=k[L-1],s.edges[k[L]].nextA=k[L+1]):console.log("For face "+b+". Face A has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):N.firstVertexB==y.firstVertexA||N.firstVertexB==y.firstVertexB?N.firstVertexA==W.firstVertexA||N.firstVertexA==W.firstVertexB?N.faceB==-1?(s.edges[k[L]].faceB=b,s.edges[k[L]].prevB=k[L-1],s.edges[k[L]].nextB=k[L+1]):console.log("For face "+b+". Face B has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):console.log("For face "+b+". Edges Don't share a vertex!")
y=s.edges[k[C-2]],N=s.edges[k[C-1]],W=s.edges[k[0]],N.firstVertexA==y.firstVertexA||N.firstVertexA==y.firstVertexB?N.firstVertexB==W.firstVertexA||N.firstVertexB==W.firstVertexB?N.faceA==-1?(s.edges[k[C-1]].faceA=b,s.edges[k[C-1]].prevA=k[C-2],s.edges[k[C-1]].nextA=k[0]):console.log("For face "+b+". Face A has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):N.firstVertexB==y.firstVertexA||N.firstVertexB==y.firstVertexB?N.firstVertexA==W.firstVertexA||N.firstVertexA==W.firstVertexB?N.faceB==-1?(s.edges[k[C-1]].faceB=b,s.edges[k[C-1]].prevB=k[C-2],s.edges[k[C-1]].nextB=k[0]):console.log("For face "+b+". Face B has already been set for edge: "+N+" With edge set: "+k):console.log("For face "+b+". Previous edge matches, but next edge doesn't share correct vertex!"):console.log("For face "+b+". Edges Don't share a vertex!")}for(var M=this.vertices.length-1;M>=0;M--){var m=this.vertices[M]
s.vertices[M].coords[0]=m.coords[0],s.vertices[M].coords[1]=m.coords[1],s.vertices[M].coords[2]=m.coords[2]}for(var P=this.edges.length-1;P>=0;P--){var D=this.edges[P],j=this.vertices[D.firstVertexA],q=this.vertices[D.firstVertexB],G=void 0
G=vectorAngle(j.coords,q.coords)
var T=[-1,-1,-1],z=[-1,-1,-1]
T[0]=-1*j.coords[0],T[1]=-1*j.coords[1],T[2]=-1*j.coords[2],z[0]=q.coords[0]-j.coords[0],z[1]=q.coords[1]-j.coords[1],z[2]=q.coords[2]-j.coords[2]
var H=void 0
H=vectorAngle(T,z)
var J=[-1,-1,-1]
J[0]=z[0]/vectorLength(z),J[1]=z[1]/vectorLength(z),J[2]=z[2]/vectorLength(z)
for(var K=vectorLength(j.coords),Q=void 0,c=0;c<r;c++)Q=Math.sin(G*((c+1)/(r+1)))*K/Math.sin(Math.PI-H-G*((c+1)/(r+1))),s.vertices[n+P*r+c].coords[0]=j.coords[0]+J[0]*Q,s.vertices[n+P*r+c].coords[1]=j.coords[1]+J[1]*Q,s.vertices[n+P*r+c].coords[2]=j.coords[2]+J[2]*Q}for(var R=0;R<this.faces.length;R++){var S=n+x*r+r*(r-1)/2*R
if(r>1)for(var U=0;U<r-1;U++){var X,Y=s.vertices[this.vertexIndexAtClockwiseIndexOnOldFace(R,0,r-2-U,r)],Z=s.vertices[this.vertexIndexAtClockwiseIndexOnOldFace(R,1,1+U,r)]
X=vectorAngle(Y.coords,Z.coords)
var $=[-1,-1,-1],_=[-1,-1,-1]
$[0]=-1*Y.coords[0],$[1]=-1*Y.coords[1],$[2]=-1*Y.coords[2],_[0]=Z.coords[0]-Y.coords[0],_[1]=Z.coords[1]-Y.coords[1],_[2]=Z.coords[2]-Y.coords[2]
var ee
ee=vectorAngle($,_)
var re=[-1,-1,-1]
re[0]=_[0]/vectorLength(_),re[1]=_[1]/vectorLength(_),re[2]=_[2]/vectorLength(_)
for(var te=vectorLength(Y.coords),se=0,c=0;c<U+1;c++)se=Math.sin(X*((c+1)/(U+2)))*te/Math.sin(Math.PI-ee-X*((c+1)/(U+2))),S+U*(U+1)/2+c>=s.vertices.length&&console.log("breakpoint"),s.vertices[S+U*(U+1)/2+c].coords[0]=Y.coords[0]+re[0]*se,s.vertices[S+U*(U+1)/2+c].coords[1]=Y.coords[1]+re[1]*se,s.vertices[S+U*(U+1)/2+c].coords[2]=Y.coords[2]+re[2]*se}}for(var ie=s.edges.length-1;ie>=0;ie--){var E,de,oe=s.edges[ie],ce=-1,fe=oe.firstVertexA,ne=s.vertices[fe]
if(ne.edges[0]==-1){xe=oe.nextEdgeForVertex(fe),ce=xe[0],de=xe[1],E=s.edges[ce],ne.edges[0]=ie
for(var l=1;ie!=ce;)ne.edges[l]=ce,ge=E.nextEdgeForVertex(fe),ce=ge[0],de=ge[1],E=s.edges[ce],l+=1}if(fe=oe.firstVertexB,ne=s.vertices[fe],ne.edges[0]==-1){ae=oe.nextEdgeForVertex(fe),ce=ae[0],de=ae[1],E=s.edges[ce],ne.edges[0]=ie
for(var l=1;ie!=ce;)ne.edges[l]=ce,ve=E.nextEdgeForVertex(fe),ce=ve[0],de=ve[1],E=s.edges[ce],l+=1}}return[s,null]
var xe,ge,ae,ve},e}()
